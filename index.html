<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Entrainement au langage SQL</title>
    <style>
        body {
            font-family: monospace;
            font-size: 12pt;
            background-color: white;
        }
        #console {
            background-color: black;
            color: white;
            width: 600px;
            height: 500px;
            margin: 2px auto;
            padding: 4px;
            overflow: scroll;
            white-space: nowrap;
        }
        p {
            white-space: pre;
            margin: 0px;
        }
        input {
            white-space: normal;
            color: #00ff00;
            background: none;
            border: none;
            outline: none;
            font-family: monospace;
            font-size: 12pt;
            width: 2000px;
        }
        label {
            color: #00ff00;
        }
        .vert {
            color: #00ff00;
        }
        .rouge {
            color: #ff8888;
        }
        .bleu {
            color: #8888ff;
        }
    </style>
</head>

<body>
    <div id="console"></div>
    <script language="javascript">
    
        /* ENVOYER LA REQUETE */
        var raw = ""
        const divConsole = document.getElementById("console")
        divConsole.addEventListener("click", setFocusToPrompt)
        divConsole.addEventListener("change", handleChange)
        print('Base de données en mode « Bac à sable » prête !', "bleu")
        prompt()
        const databases = []
        var currentDatabase = null
        class Database {
            constructor(nom) {
                this.nom = nom
                this.tables = {}
            }
            addTable(nom) {
                if (this.tables[nom]) {
                    throw `La base « ${this.nom} » comporte déjà une table nomée « ${nom} »`
                } else {
                    this.tables[nom] = new Table(nom, this)
                }
            }
            removeTable(nom) {
                if (this.tables[nom]) {
                    delete this.tables[nom]
                } else {
                    throw `Il n'y a aucune table « ${nom} » dans la base « ${this.nom} »`
                }
            }
        }
        
        class Table {
            constructor(nom, base) {
                this.nom = nom
                this.columns = {}
                this.data = []
                this.base = base
            }
            addColumn(nom, type) {
                if (this.columns[nom]) {
                    throw `La table « ${this.nom} » comporte déjà une colonne nomée « ${nom} ».`
                }
                this.columns[nom] = new Column(nom, type, this)
            }
            addData(element) {
                const colonneInconnue = Object.keys(element).filter(key => !this.columns[key])
                if (colonneInconnue.length == 1) {
                    throw `La table « ${this.nom} » ne comporte pas de colonne « ${colonneInconnue[0]} ».`
                } else if (colonneInconnue.length > 1) {
                    throw `La table « ${this.nom} » ne comporte pas de colonnes « ${colonneInconnue.join(', ')} ».`
                } else {
                    this.data.push(element)
                    for (const key in element) {
                        const newLength = element[key].toString().length
                        const column = this.columns[key]
                    }
                }
            }
        }
        
        class Column {
            constructor(nom, type, table) {
                const dicoTypes = {
                    "SMALLINT" : (l) => {elem => {elem >= -32768 && elem <= 32767}},
                    "INT" : (l) => {elem => {elem >= -2147483648 && elem <= 2147483647}},
                    "CHAR" : (l) => {l ? elem => {elem.length == l} : dicoTypes["CHAR"](1)},
                    "VARCHAR" : (l) => {l ? elem => {elem.length <= l} : dicoTypes["VARCHAR"](255)},
                    "DATE" : (l) => { if (l) { throw "Le type « DATE » n'accepte pas de paramètres." } else { return checkDate }}
                }
                const regExp = /^([a-z]+)(\(([0-9])*\))?$/i
                const matchType = type.match(regExp)
                const nomType = matchType[1] 
                if (!dicoTypes[nomType]) {
                    throw `Le type  « ${type} » n'est pas reconnu.`
                }
                this.type = type
                this.longueur = matchType[3]
                this.controleType = dicoTypes[nomType](this.longueur)
                this.nom = nom
                this.table = table
            }
        }

        /*
         * Un fragment de la requete ayant un sens propre
         */
        class Token {
            constructor(nom, delimiteur) {
                this.nom = nom
                this.delimiteur = delimiteur
            }
        }

        /*
         * Contient toutes les informations pour controler et executer la requette.
         */
        class Request {
            constructor(raw) {
                this.raw = raw
                this.SQL = raw.replace("\n", " ")
                this.tokensList = []
                this.index = 0
                this.distinct = false
                this.columnsAliasList = []
                this.columnsNamesList = []
                this.tablesNamesList = []
                this.whereList = []
                this.orderByNameList = []
                this.columnsList = []
                this.tablesList = []
                this.orderByList = []
                this.descList = []
                this.combinaisons = []
                this.limite = null
                this.offset = 0
                this.valueslist = []
            }
        }

        
        /*
         * produit cartésien d'une liste de n tables
         */
        function produitCartesien(L) {
            return L.reduce((acc, cur) => {
                const newAcc = []
                const data = cur.data
                if (acc.length) {
                    acc.forEach(elemAcc => {
                        data.forEach( elem => {
                            const obj = {...elemAcc}
                            obj[cur.nom] = elem
                            newAcc.push(obj)
                        })
                    })
                } else {
                    data.forEach( elem => {
                        const obj = {}
                        obj[cur.nom] = elem
                        newAcc.push(obj)
                    })
                }
                return newAcc
            }, [])
        }
        
        /*
         * retourne un callback permettant de trier selon les paramètres à utiliser par la fonction sort
         */
        function tri(cols, desc) {
            const callback = (obj1, obj2) => {
                for (i=0; i<cols.length; i++) {
                    const col = cols[i]
                    const preelem1 = obj1[col.table.nom][col.nom]
                    const elem1 = typeof preelem1 == "string" ? preelem1.toUpperCase() : preelem1
                    const preelem2 = obj2[col.table.nom][col.nom]
                    const elem2 = typeof preelem2 == "string" ? preelem2.toUpperCase() : preelem2
                    if (elem1 < elem2) {
                        return desc[i] ? -1 : 1
                    } else if (elem1 > elem2) {
                        return desc[i] ? 1 : -1
                    }
                }
                return true
            }
            return callback
        }

        /*
         * ajoute autant d'espace que necessaire pour obtenir une chaine de bonne longueur.
         * si le texte est trop long, retourne le texte tel quel.
         */
        function expandText(texte, longueur) {
            if (longueur>=texte.length) {
                return texte + " ".repeat(longueur-texte.length)
            } else {
                return texte
            }
        }
        /*
         * affiche une ligne dans le cadre 'réponse'
         */
        function print(texte, classe) {
            const p = document.createElement("p")
            p.textContent = texte
            p.className = classe ? classe : ""
            divConsole.appendChild(p)
            divConsole.scrollTop = divConsole.scrollHeight;
        }
        
        /*
         * Donne le focus au prompt
         */
        function setFocusToPrompt(event) {
            divConsole.lastChild.focus()
        }
        
        /*
         * affiche un prompt et une barre clignotante
         */
        function prompt() {
            const label = document.createElement("label")
            label.textContent = ">"
            const input = document.createElement("input")
            input.type = "text"
            input.className = "requete"
            divConsole.appendChild(label)
            divConsole.appendChild(input)
            divConsole.scrollTop = divConsole.scrollHeight;
            input.focus()
        }
        
        /*
         * affiche des données sous la forme d'un tableau dans le cadre 'réponse'
         */
        function printTable(entete, data, distinct) {
            const largeurs = []
            for (i=0; i<entete.length; i++) {
                largeurs.push(entete[i].toString().length)
                for (j=0; j<data.length; j++) {
                    if (largeurs[i] < data[j][i].toString().length) {
                        largeurs[i] = data[j][i].toString().length
                    }
                }
            }
            const ligne = "+" + largeurs.map(l => '-'.repeat(l+2)).join("+") + "+"
            print(ligne)
            print("| " + entete.map((col, i) => expandText(col.toString(), largeurs[i])).join(" | ") + " |")
            print(ligne)
            var listeTextes = data.map(row => "| " + row.map((col, i) => expandText(col.toString(), largeurs[i])).join(" | ") + " |")
            if (distinct) {
                listeTextes = Array.from(new Set(listeTextes))
            }
            const nb = listeTextes.length
            listeTextes.forEach(row => {
                print(row)
                print(ligne)
            })
            print(`${nb} ${nb>1?"lignes":"ligne"}`, "bleu")
        }

        /* 
         * Parcours la chaine de caractère `raw` à la recherche d'un ; à partir de la position `index`
         * Retourne une erreur si le caractère ; n'est pas trouvé
         */
        function searchString(R, delimiteur) {
            R.index += 1
            var txt = ""
            while (R.raw[R.index] && R.raw[R.index] != delimiteur) {
                txt += R.raw[R.index]
                R.index += 1
            }
            if (R.raw[R.index]) {
                R.tokensList.push(new Token(txt, 'quotes'))
                R.index += 1
            } else {
                throw `Il manque un caractère « ${delimiteur} » fermant la chaîne de catactères.`
            }
        }

        /* 
         * Parcours la chaine de caractère `raw` à la recherche de parenthèse à partir de la position `index`
         * Retourne une erreur si le caractère ; n'est pas trouvé
         */
        function searchParentheses(R) {
            var nombreParenthese = 1
            R.index += 1
            var txt = ""
            while (R.raw[R.index] && nombreParenthese > 0) {
                if (R.raw[R.index] == ")") {
                    nombreParenthese += -1
                } else if (R.raw[R.index] == "(") {
                    nombreParenthese += 1
                }
                if (nombreParenthese > 0) {
                    txt += R.raw[R.index]
                    R.index += 1
                }
            }
            if (R.raw[R.index]) {
                R.tokensList.push(new Token(txt, 'parentheses'))
                R.index += 1
            } else {
                throw 'Il manque une parenthèse fermante.'
            }
        }

        /* 
         * Parcours la chaine de caractère `raw` à la recherche d'un nombre
         */
        function searchNumber(R) {
            var nb = ""
            while (R.raw[R.index] && "0123456789.-".indexOf(R.raw[R.index]) > -1) {
                nb += R.raw[R.index]
                R.index += 1
            }
            if (nb.split('.').length < 2 && nb.split('-').length == 1) {
                R.tokensList.push(new Token(nb, "number"))
            } else if (nb.split('-').length == 3 && nb.split('.').length == 1) {
                R.tokensList.push(new Token(nb, "date"))
            } else {
                throw "Une erreur lors de la recherche d'une valeur numérique"
            }
        }

        /* 
         * Parcours la chaine de caractère `raw` à la recherche d'un opérateur de comparaison
         */
        function getOperateur(R) {
            if (R.raw[R.index] == '!') {
                if (R.raw[R.index + 1] && R.raw[R.index + 1] == '=') {
                    R.index += 2
                    R.tokensList.push(new Token("!=", "operateur"))
                } else {
                    throw "Caractère « ! » inattendu."
                }
            }
            if (R.raw[R.index] == '<') {
                if (R.raw[R.index + 1] && R.raw[R.index + 1] == '>') {
                    R.index += 2
                    R.tokensList.push(new Token("<>", "operateur"))
                } else if (R.raw[R.index + 1] && R.raw[R.index + 1] == '=') {
                    R.index += 2
                    R.tokensList.push(new Token("<=", "operateur"))
                } else {
                    R.index += 1
                    R.tokensList.push(new Token("<", "operateur"))
                }
            }
            if (R.raw[R.index] == '>') {
                if (R.raw[R.index + 1] && R.raw[R.index + 1] == '=') {
                    R.index += 2
                    R.tokensList.push(new Token(">=", "operateur"))
                } else {
                    R.index += 1
                    R.tokensList.push(new Token(">", "operateur"))
                }
            }
        }

        /* 
         * Parcours la chaine de caractère `sql` de la requête `R` pour la découper en "tokens"
         */
        function tokenize(R) {
            const specialChar = {
                "'": R => searchString(R, "'"),
                '"': R => searchString(R, '"'),
                "(": searchParentheses,
                " ": R => {R.index += 1},
                ",": R => {R.index += 1; R.tokensList.push(new Token(",", null))},
                "!": getOperateur,
                "<": getOperateur,
                ">": getOperateur,
                "0": searchNumber,
                "1": searchNumber,
                "2": searchNumber,
                "3": searchNumber,
                "4": searchNumber,
                "5": searchNumber,
                "6": searchNumber,
                "7": searchNumber,
                "8": searchNumber,
                "9": searchNumber,
            }
            const endChar = ["'", '"', "(", ' ', "=", ">", "<", ";", ',']
            if (specialChar[R.raw[R.index]]) {
                specialChar[R.raw[R.index]](R)
            } else {
                var txt = R.raw[R.index]
                R.index += 1
                while (R.raw[R.index] && endChar.indexOf(R.raw[R.index]) == -1) {
                    txt += R.raw[R.index]
                    R.index += 1
                }
                R.tokensList.push(new Token(txt, null))
            }
        }

        /*
         * Parcours le texte saisi par l'utilisateur à la recherche de requettes
         * et les contrôle puis les execute au fur et à mesure.
         */
        function parseSQL(raw) {
            var R = new Request(raw.substring(0, raw.length-1))
            prepare(R)
            execute(R)
            prompt()
        }
        
        /*
         * Change l'input en une div.
         * Si la requête fini bien par un ; lance l''interpreter
         */
        function handleChange(event) {
            event.preventDefault()
            const text = divConsole.lastChild.value.trim()
            raw = raw + " " + text
            divConsole.removeChild(divConsole.lastChild)
            divConsole.removeChild(divConsole.lastChild)
            const p = document.createElement("p")
            p.className = "vert"
            p.textContent = ">" + text
            divConsole.appendChild(p)
            if (text[text.length - 1] == ";") {
                interpreter(raw)
                raw = ""
            } else {
                prompt()
            }
        }
        
        /*
         * Lance la séquence d'interprétation et affiche un message d'erreur si besoin.
         */
        function interpreter() {
            try {
                parseSQL(raw)
            } catch (e) {
                print(e, "rouge")
                prompt()
            }
        }
        
        /*
         * applique le prochain mot clé s'il est reconnu
         */
        function applyNextKeyword(R, dict) {
            if (R.tokensList.length > R.index) {
                const keyword = R.tokensList[R.index].nom.toUpperCase()
                if (dict[keyword]) {
                    R.index += 1
                    dict[keyword](R)
                } else {
                    throw `Le mot clé « ${keyword} » n'est pas reconnu.`
                }
            } else {
                throw `Requête incomplète.`
            }
        }
        
        /*
         * vérifie si la requête continue
         */
        function existNextToken(R) {
            return R.tokensList.length > R.index
        }
        
        /*
         * lit le nom du prochain token sans changer l'index
         */
        function getNameFromToken(R) {
            if (existNextToken(R)) {
                const name = R.tokensList[R.index].nom
                return name
            } else {
                throw `Requête incomplète.`
            }
        }
        
        /*
         * récupère le prochain token
         */
        function getNextToken(R) {
            if (existNextToken(R)) {
                R.index += 1
                return R.tokensList[R.index - 1]
            } else {
                throw `Requête incomplète.`
            }
        }
        
        /*
         * Retrouve une base de données par son nom
         */
        function findDatabase(nom) {
            const dbList = databases.filter(db => db.nom.toUpperCase() == nom.toUpperCase())
            if (dbList.length) {
                return dbList[0]
            } else {
                throw `Erreur, il n'y a aucune base de données nomée « ${nom} ».`
            }
        }
        
        /*
         * Retrouve une table par son nom dans la base de données courante
         */
        function findTable(nom) {
            if (currentDatabase) {
                if (currentDatabase.tables[nom]) {
                    return currentDatabase.tables[nom]
                } else {
                    throw `Erreur, il n'y a pas de table nomée « ${nom} » dans la base de données « ${currentDatabase.nom} ».`
                }
            } else {
                throw "Aucune base de données n'est sélectionnée."
            }
        }
        
        /*
         * Retrouve une colonne par son nom dans une liste de tables
         */
        function findColumn(col, tablesList) {
            if (col.table) {
                const liste = tablesList.filter(tab => tab.nom == col.table)
                if (liste.length > 0) {
                    const table = liste[0]
                    if (table.columns[col.nom]) {
                        return table.columns[col.nom]
                    } else {
                        throw `La colonne « ${col.nom} » est introuvable dans la table ${col.table}.`
                    }
                } else {
                    throw `La table « ${col.table} » n'est pas dans la liste des tables sélectionnées.`
                }
            } else {
                const liste = tablesList.filter(tab => tab.columns[col.nom])
                if (liste.length == 1) {
                    return liste[0].columns[col.nom]
                } else if (liste.length == 2) {
                    throw `Une colonne « ${col.nom} » est présente dans plusieurs tables sélectionnées.`
                } else {
                    throw `La colonne « ${col.nom} » est introuvable dans ${tablesList.length > 1 ? "la liste des tables sélectionnées" : "la table sélectionnée"}.`
                }
            }
        }
        
        /*
         * prepare une requete en la séparant en tokens.
         */
        function prepare(R) {
            while (R.index < R.raw.length) {
                tokenize(R)
            }
        }
        
        /*
         * sépare le nom de la table du nom de la colonne.
         * retourne un objet décrivant la table
         */
        function setColumn(nom) {
            const liste = nom.split(".")
            if (liste.length == 2) {
                return {nom: liste[1], table: liste[0]}
            } else if (liste.length == 1) {
                return {nom: liste[0], table: null}
            } else {
                throw `Trop de « . » dans le nom de colonne « ${next.nom} »`
            }
        }
        
        
        /*
         * execute une requete
         */
        function execute(R) {
            R.index = 0
            const firstKeyword = {
                "SHOW": show,
                "USE": use,
                "DESC": describe,
                "DESCRIBE": describe,
                "SELECT": select,
                "CREATE": create,
                "INSERT": insert,
            }
            applyNextKeyword(R, firstKeyword)
        }
        
        /*
         * fonctions de comparaison
         */
        class ComparateurUnaire {
            constructor(A, not, comparateur) {
                this.binaire = false
                this.A = A
                this.not = not
                this.f = (E) => {
                    var a
                    if (this.A.delimiteur) {
                        a = this.A.nom
                    } else {
                        a = E[this.A.table.nom][this.A.nom]
                    }
                    const reponse = this.not ? !comparateur(a) : comparateur(a)
                    return reponse
                }
            }
        }

        class ComparateurBinaire {
            constructor(A, B, not, comparateur) {
                this.binaire = true
                this.A = A
                this.B = B
                this.not = not
                this.f = (E) => {
                    var a, b
                    if (this.A.delimiteur) {
                        a = this.A.nom
                    } else {
                        a = E[this.A.table.nom][this.A.nom]
                    }
                    if (this.B.delimiteur) {
                        b = this.B.nom
                    } else {
                        b = E[this.B.table.nom][this.B.nom]
                    }
                    const reponse = this.not ? !comparateur(a, b) : comparateur(a, b)
                    return reponse
                }
            }
        }
        
        const dicoCompare = {
            '=': (A, B, not) => new ComparateurBinaire(A, B, not, (a, b) => a==b),
            '!=': (A, B, not) => new ComparateurBinaire(A, B, not, (a, b) => a!=b),
            '<>': (A, B, not) => new ComparateurBinaire(A, B, not, (a, b) => a!=b),
            '>': (A, B, not) => new ComparateurBinaire(A, B, not, (a, b) => a>b),
            '<': (A, B, not) => new ComparateurBinaire(A, B, not, (a, b) => a<b),
            '>=': (A, B, not) => new ComparateurBinaire(A, B, not, (a, b) => a>=b),
            '<=': (A, B, not) => new ComparateurBinaire(A, B, not, (a, b) => a<=b),
        }
        function appartientA(A, L) {return L.indexOf(A) > -1}
        function entre(A, m, M) {return A >= m && A <= M}
        function like(A, S) {
            const regExp = new RegExp(`^${A.split('%').join('.*').split('_').join('.')}$`)
            return regExp.test(S)
        }
        function estNulle(A) {return A == null}
        function estPasNulle(A) {return A != null}
        function compare_binaire(A, B, symbole) {
            if (dicoCompare[symbole]) {
                return dicoCompare[symbole](A, B)
            } else {
                throw `L'opérateur de comparaison « ${symbole} » non valable.`
            }
        }
        
        /*
         * fonctions de contrôle
         */
        function is_int(value){
            if((parseFloat(value) == parseInt(value)) && !isNaN(value)){ 
                return true;
            }
            return false;
        }
        
        function checkDate(value){
            const regExp = /^([0-9]{4})-([0-1][0-9])-([0-2][0-9])$/
            if (regExp.test(value)) {
                const date = value.match(regExp)
                if (date[1] < 1000) {return false}
                if (date[2] > 12) {return false}
                if ([1, 3, 5, 7, 8, 10, 12].indexOf(date[3])) {
                    if (date[3] > 31) {return false}
                } else if (date[3] == 2) {
                    if (date[3] > 29) {return false}
                } else {
                    if (date[3] > 30) {return false}
                }
                return true
            } else {
                return false
            }
        }
        
        
        /*
         * traite le mot-clé mysql 'SHOW'
         */
        function show(R) {
            const nextKeywords = {
                "DATABASES": showDatabases,
                "TABLES": showTables
            }
            applyNextKeyword(R, nextKeywords)
        }
        
        /*
         * traite la commande mysql 'SHOW DATABASES'
         */
        function showDatabases(R) {
            const dbList = databases.map(db => [db.nom])
            printTable(["DATABASES"], dbList, false)
        }
        
        /*
         * traite la commande mysql 'SHOW TABLES'
         */
        function showTables(R) {
            if (currentDatabase) {
                const tablesList = Object.keys(currentDatabase.tables).map(nom => [nom])
                printTable([`TABLES in ${currentDatabase.nom}`], tablesList, false)
            } else {
                throw "Aucune base de données sélectionnée."
            }
        }

        /*
         * traite la commande mysql 'USE'
         */
        function use(R) {
            const nom = getNameFromToken(R)
            R.index += 1
            currentDatabase = findDatabase(nom)
            if (existNextToken(R)) {
                throw `Le mot-clé ${getNameFromToken(R)} innatendu`
            }
            print(`La base de données « ${nom} » a bien été selectionnée.`)
        }
        
        /*
         * traite la commande mysql 'DESCRIBE'
         */
        function describe(R) {
            const nom = getNameFromToken(R)
            R.index += 1
            const table = findTable(nom)
            const infos = Object.values(table.columns).map(lbl => [lbl.nom, lbl.type])
            const largeurs = [Math.max(...infos.map(L => L[0].length)),
                              Math.max(...infos.map(L => L[1].length))]
            if (existNextToken(R)) {
                throw `Le mot clé ${getNameFromToken(R)} est inattendu`
            }
            printTable(["COLUMN'S NAME", "TYPE"], infos)
        }
        
        /*
         * traite le mot-clé mysql 'SELECT'
         */
        function select(R) {
            const next = getNameFromToken(R)
            if (next.toUpperCase() == "DATABASE") {
                R.index += 1
                selectDatabase(R)
            } else if (next.toUpperCase() == "DISTINCT") {
                R.distinct = true
                R.index += 1
                selectFrom(R)
            } else {
                selectFrom(R)
            }
        }
        
        /*
         * traite la commande mysql 'SELECT database()'
         */
        function selectDatabase(R) {
            const token = getNextToken(R)
            if (token.nom == "" && token.delimiteur == "parentheses") {
                print(`La base de données « ${currentDatabase.nom} » est actuellement selectionnée.`)
            } else {
                throw "Aucune base de données sélectionnée."
            }
        }
        
        /*
         * traite la commande mysql 'SELECT FROM'
         */
        function selectFrom(R) {
            exploreColumns(R)
            exploreTables(R)
            checkTables(R)
            checkColumns(R)
            selectWhere(R)
            selectOrderBy(R)
            selectLimit(R)
            selectOffset(R)
            showSelectResults(R)
        }
        
        /*
         * recherche le nom des colonnes à afficher pour un SELECT FROM
         */
        function exploreColumns(R) {
            var next = {nom: ","}
            while (next.nom == ",") {
                next = getNextToken(R)
                if (next.delimiteur == null) {
                    const col = setColumn(next.nom)
                    R.columnsNamesList.push(col)
                    if (next.nom.indexOf("*") == -1) {
                        const mot_cle = getNameFromToken(R)
                        if (mot_cle.toUpperCase() == "AS") {
                            R.index += 1
                            next = getNextToken(R)
                            R.columnsAliasList.push(next.nom)
                        } else {
                            R.columnsAliasList.push(next.nom)
                        }
                    }
                    next = getNextToken(R)
                } else {
                    throw `Un nom de colonne est attendu entre les mots clés SELECT et FROM.`
                }
            }
            R.index += -1
        }
        
        /*
         * recherche le nom des sources de données et eventuellement les alias avant de faire un SELECT FROM
         */
        function exploreTables(R) {
            const token = getNameFromToken(R)
            R.index += 1
            if (token.toUpperCase() == "FROM") {
                var next = {nom: ","}
                while (next.nom == ",") {
                    next = getNextToken(R)
                    if (next.delimiteur == null) {
                        R.tablesNamesList.push(next.nom)
                        if (existNextToken(R)) {
                            next = getNextToken(R)
                        } else {
                            next = " "
                            R.index += 1
                        }
                    } else {
                        throw `Un nom de table est attendu après le mot clé FROM.`
                    }
                }
            } else {
                throw `Le mot clé « ${token} » est inattendu`
            }
            R.index += -1
        }
        
        /*
         * controle et associe les tables utilisées pour un SELECT FROM
         */
        function checkTables(R) {
            R.tablesList = R.tablesNamesList.map(table => findTable(table))
        }
        
        /*
         * controle et associe les colonnes afin de faire un SELECT FROM
         */
        function checkColumns(R) {
            R.columnsNamesList.forEach(col => {
                if (col.table && col.nom == "*") {
                    const table = R.tablesList.filter(tab => tab.nom == col.table)[0]
                    if (table) {
                        Array.prototype.push.apply(R.columnsList, Object.values(table.columns));
                        Array.prototype.push.apply(R.columnsAliasList, Object.values(table.columns).map(col => `${col.table.nom}.${col.nom}`));
                    } else {
                        throw `La table « ${col.table} » n'est pas dans la liste des tables sélectionnées.`
                    }
                } else if (col.nom == "*") {
                    R.tablesList.forEach(tab => {
                        Array.prototype.push.apply(R.columnsList, Object.values(tab.columns));
                        Array.prototype.push.apply(R.columnsAliasList, Object.values(tab.columns).map(col => `${col.nom}`));
                    })
                } else {
                    R.columnsList.push(findColumn(col, R.tablesList))
                }
            })
            R.combinaisons = produitCartesien(R.tablesList)
        }
        
        /*
         * traite si besoin le mot clé WHERE de la requete SELECT
         */
        function selectWhere(R) {
            if (existNextToken(R)) {
                if (getNameFromToken(R).toUpperCase() == "WHERE") {
                    R.index += 1
                    exploreWhere(R)
                    checkWhere(R)
                    applyWhere(R)
                }
            }
        }
        
        /*
         * recherche les comparaisons pour un WHERE
         */
        function exploreWhere(R) {
            const A = getNextToken(R)
            const symbole = getNextToken(R).nom
            const not = false
            if (symbole.toUpperCase() == "IS") {
                var next = getNextToken(R)
                if (next.nom.toUpperCase() == "NULL") {
                    R.whereList.push(new ComparateurUnaire(A, not, (a) => a = null))
                } else if (next.nom.toUpperCase() == "NOT") {
                    next = getNextToken(R)
                    if (next.nom.toUpperCase() == "NULL") {
                        R.whereList.push(new ComparateurUnaire(A, not, (a) => a != null))
                    } else {
                        throw "Condition non comprise"
                }
                } else {
                    throw "Condition non comprise"
                }
            } else if (dicoCompare[symbole]) {
                const B = getNextToken(R)
                R.whereList.push(dicoCompare[symbole](A, B, not))
            } else {
                throw `Comparaison « ${symbole} » pas encore gérée...`
            }
            if (existNextToken(R) && getNameFromToken(R).toUpperCase() == "AND") {
                R.index += 1
                exploreWhere(R)
            }
        }
        
        /*
         * vérifie les paramètres de Where
         */
        function checkWhere(R) {
            R.whereList.forEach(e => {
                if (e.A.delimiteur) {
                    if (['quotes','number','date'].indexOf(e.A.delimiteur) == -1) {
                        throw `La paramètre « ${e.A.nom} » est inattendu`
                    }
                } else {
                    e.A = findColumn(setColumn(e.A.nom), R.tablesList)
                }
                if (e.binaire) {
                    if (e.B.delimiteur) {
                        if (['quotes','number','date'].indexOf(e.B.delimiteur) == -1) {
                            throw `La paramètre « ${e.B.nom} » est inattendu`
                        }
                    } else {
                        e.B = findColumn(setColumn(e.B.nom), R.tablesList)
                    }
                }
            })
        }
        
        /*
         * filtres les données grâces aux comparaisons
         */
        function applyWhere(R) {
            R.whereList.forEach(where => {
                R.combinaisons = R.combinaisons.filter(E => where.f(E))
            })
        }
        
        /*
         * traite si besoin le mot clé ORDER BY de la requete SELECT
         */
        function selectOrderBy(R) {
            if (existNextToken(R)) {
                if (getNameFromToken(R).toUpperCase() == "ORDER") {
                    R.index += 1
                    const next = getNextToken(R)
                    if (next.nom.toUpperCase() == "BY") {
                        exploreOrderBy(R)
                        checkOrderBy(R)
                        applyOrderBy(R)
                    } else {
                        throw `Requête invalide, vérifier la clause « ORDER ${next.nom} »`
                    }
                }
            }
        }
        
        /*
         * recherche les tables pour un ORDER BY
         */
        function exploreOrderBy(R) {
            var next = {nom: ","}
            while (next.nom == "," || next.nom.toUpperCase() == "DESC") {
                if (next.nom.toUpperCase() == "DESC") {
                    R.descList.pop()
                    R.descList.push(false)
                    if (existNextToken(R)) {
                        next = getNextToken(R)
                    } else {
                        next = {nom: ""}
                    }
                } else {
                    R.descList.push(true)
                    next = getNextToken(R)
                    if (next.delimiteur == null) {
                        const liste = next.nom.split(".")
                        if (liste.length == 2) {
                            R.orderByNameList.push({nom: liste[1], table: liste[0]})
                        } else if (liste.length == 1) {
                            R.orderByNameList.push({nom: liste[0], table: null})
                        } else {
                            throw `Trop de « . » dans le nom de colonne « ${next.nom} »`
                        }
                        if (existNextToken(R)) {
                            next = getNextToken(R)
                        } else {
                            next = {nom: ""}
                        }
                    } else {
                        throw `Un nom de colonne est attendu après ORDER BY.`
                    }
                }
            }
        }
        
        /*
         * vérifie les colonnes afin de faire un tri grâce à ORDER BY
         */
        function checkOrderBy(R) {
            R.orderByNameList.forEach(col => {
                R.orderByList.push(findColumn(col, R.tablesList))
            })
        }
        
        /*
         * traite la commande ORDER BY suite à un 'SELECT FROM'
         */
        function applyOrderBy(R) {
            R.combinaisons.sort(tri(R.orderByList, R.descList))
        }
        
        
        /*
         * cherche et sauvegarde le nombre de résultats à afficher
         */
        function selectLimit(R) {
            if (existNextToken(R)) {
                if (getNameFromToken(R).toUpperCase() == "LIMIT") {
                    R.index += 1
                    const next = getNextToken(R)
                    if (is_int(next.nom)) {
                        if (parseInt(next.nom) < 0) {
                            throw "Requête invalide, un nombre entier positif est attendu dans la clause « LIMIT »"
                        }
                        R.limit = parseInt(next.nom)
                    } else {
                        throw "Requête invalide, un nombre entier est attendu dans la clause « LIMIT »"
                    }
                }
            }
        }
        
        /*
         * cherche et sauvegarde le nombre de résultats à ignorer
         */
        function selectOffset(R) {
            if (existNextToken(R)) {
                if (getNameFromToken(R).toUpperCase() == "OFFSET") {
                    R.index += 1
                    const next = getNextToken(R)
                    if (is_int(next.nom)) {
                        if (parseInt(next.nom) < 0) {
                            throw "Requête invalide, un nombre entier positif est attendu dans la clause « OFFSET »"
                        }
                        R.offset = parseInt(next.nom)
                    } else {
                        throw "Requête invalide, un nombre entier est attendu dans la clause « OFFSET »"
                    }
                }
            }
        }
        
        /*
         * affiche uniquement les colonnes désirées
         */
        function showSelectResults(R) {
            if (existNextToken(R)) {
                throw `Mot clé « ${getNameFromToken(R)} » inattendu`
            }
            const entete = R.columnsAliasList
            const data = R.combinaisons.map(elem => R.columnsList.map(col => elem[col.table.nom][col.nom]))
            if (R.limit ==  null) {
                printTable(entete, data.splice(R.offset), R.distinct)
            } else {
                printTable(entete, data.splice(R.offset, R.limit), R.distinct)
            }
        }
        
        /*
         * traite le mot-clé mysql 'CREATE'
         */
        function create(R) {
            const nextKeywords = {
                "DATABASE": createDatabase,
                "TABLE": createTable
            }
            applyNextKeyword(R, nextKeywords)
        }
        
        function createDatabase(R) {
            const nom = getNameFromToken(R)
            R.index += 1
            try {
                currentDatabase = findDatabase(nom)
                throw "existe"
            } catch (e) {
                if (e == "existe") {
                    throw `Une base nommée « ${nom} » existe déjà.`
                }
            }
            if (existNextToken(R)) {
                throw `Le mot-clé ${getNameFromToken(R)} est innatendu`
            }
            databases.push(new Database(nom))
            print(`La base de données « ${nom} » a bien été créée.`)
        }
        
        function createTable(R) {
            const nom = getNameFromToken(R)
            R.index += 1
            if (!currentDatabase) {
                throw "Aucune base de données n'est sélectionnée."
            }
            currentDatabase.addTable(nom)
            const table = currentDatabase.tables[nom]
            try {
                const token = getNextToken(R)
                const L = token.nom.trim().split(',').map(elem => elem.trim().split(" "))
                L.forEach(elem => {
                    if (elem.length != 2) {
                        throw `Erreur lors de la lecture des tables : ${elem.join(" ")}`
                    }
                    table.addColumn(elem[0], elem[1].toUpperCase())
                })
                if (existNextToken(R)) {
                    throw `Le mot-clé « ${getNameFromToken(R)} » est innatendu`
                }
            } catch (e) {
                currentDatabase.removeTable(nom)
                throw e
            }
            print(`La table « ${nom} » a bien été créée.`)
        }
        
        /*
         * traite le mot-clé mysql 'INSERT'
         */
        function insert(R) {
            if (!currentDatabase) {
                throw "Aucune base de données n'est sélectionnée."
            }
            if (getNextToken(R).nom.toUpperCase() != "INTO") {
                throw "Le mot clé « INTO » est attendu après le mot clé « INSERT »."
            }
            const token = getNextToken(R)
            R.table = findTable(token.nom)
            exploreInsertColumns(R)
            exploreInsertValues(R)
            applyInsert(R)
        }
        
        /*
         * recherche les colonnes pour une requête INSERT
         */
        function exploreInsertColumns(R) {
            const next = getNextToken(R)
            if (next.nom.toUpperCase() == "VALUES") {
                for (const col in R.table) {
                    R.columnsList.push(col)
                }
            } else if (next.delimiteur == "parentheses") {
                const listeNoms = next.nom.split(',')
                listeNoms.forEach(nom => R.columnsList.push(findColumn({nom: nom.trim()}, [R.table])))
            } else {
                throw "Erreur lors de la lecture du nom des colonnes."
            }
        }
        
        /*
         * recherche les valeurs pour une requête INSERT
         */
        function exploreInsertValues(R) {
        
        }
        
        /*
         * enregistre les données suite à une requête INSERT
         */
        function applyInsert(R) {
        
        }
        
        /*
         * un exemple de database sur les sériers et acteurs des Emmy Awards 2018
         */
        const db_emmy = new Database("emmy18")
        db_emmy.addTable("series")
        db_emmy.tables["series"].addColumn("id", "SMALLINT")
        db_emmy.tables["series"].addColumn("nom", "VARCHAR")
        db_emmy.tables["series"].addColumn("diffuseur", "VARCHAR")
        db_emmy.tables["series"].addData({id: 1, nom: "Game of Thrones", diffuseur: "HBO"})
        db_emmy.tables["series"].addData({id: 2, nom: "The Americans", diffuseur: "FX"})
        db_emmy.tables["series"].addData({id: 3, nom: "The Crown", diffuseur: "Netflix"})
        db_emmy.tables["series"].addData({id: 4, nom: "The Handmaid's Tale : La Servante écarlate", diffuseur: "Hulu"})
        db_emmy.tables["series"].addData({id: 5, nom: "Stranger Things", diffuseur: "Netflix"})
        db_emmy.tables["series"].addData({id: 6, nom: "This Is Us", diffuseur: "NBC"})
        db_emmy.tables["series"].addData({id: 7, nom: "Westworld", diffuseur: "HBO"})
        db_emmy.tables["series"].addData({id: 8, nom: "Ozark", diffuseur: "Netflix"})
        db_emmy.tables["series"].addData({id: 9, nom: "Orphan Black", diffuseur: "BBC America"})
        db_emmy.tables["series"].addData({id: 10, nom: "Killing Eve", diffuseur: "BBC America"})
        db_emmy.tables["series"].addData({id: 11, nom: "Homeland", diffuseur: "Showtime"})
        db_emmy.tables["series"].addData({id: 12, nom: "Mme Maisel, femme fabuleuse", diffuseur: "Amazon"})
        db_emmy.tables["series"].addData({id: 13, nom: "Atlanta", diffuseur: "FX"})
        db_emmy.tables["series"].addData({id: 14, nom: "Barry", diffuseur: "HBO"})
        db_emmy.tables["series"].addData({id: 15, nom: "Black-ish", diffuseur: "ABC"})
        db_emmy.tables["series"].addData({id: 16, nom: "Larry et son nombril", diffuseur: "HBO"})
        db_emmy.tables["series"].addData({id: 17, nom: "GLOW", diffuseur: "Netflix"})
        db_emmy.tables["series"].addData({id: 18, nom: "Silicon Valley", diffuseur: "HBO"})
        db_emmy.tables["series"].addData({id: 19, nom: "Unbreakable Kimmy Schmidt", diffuseur: "Netflix"})
        db_emmy.tables["series"].addData({id: 20, nom: "The Good Place", diffuseur: "NBC"})
        db_emmy.tables["series"].addData({id: 21, nom: "Shameless", diffuseur: "Showtime"})
        db_emmy.tables["series"].addData({id: 22, nom: "Better Things", diffuseur: "FX"})
        db_emmy.tables["series"].addData({id: 23, nom: "Mom", diffuseur: "CBS"})
        db_emmy.tables["series"].addData({id: 24, nom: "Insecure", diffuseur: "HBO"})
        db_emmy.tables["series"].addData({id: 25, nom: "Grace et Frankie", diffuseur: "Netflix"})
        db_emmy.tables["series"].addData({id: 26, nom: "Baskets", diffuseur: "FX"})
        db_emmy.tables["series"].addData({id: 27, nom: "Roseanne", diffuseur: "ABC"})
        db_emmy.tables["series"].addData({id: 28, nom: "Will et Grace", diffuseur: "NBC"})

        db_emmy.addTable("acteurs")
        db_emmy.tables["acteurs"].addColumn("id", "SMALLINT")
        db_emmy.tables["acteurs"].addColumn("nom", "VARCHAR")
        db_emmy.tables["acteurs"].addColumn("prenom", "VARCHAR")
        db_emmy.tables["acteurs"].addColumn("sexe", "CHAR(1)")
        db_emmy.tables["acteurs"].addColumn("pays", "VARCHAR")
        db_emmy.tables["acteurs"].addColumn("date_de_naissance", "DATE")
        db_emmy.tables["acteurs"].addData({id: 1, nom: "Rhys", prenom: "Matthew", sexe: "M", pays: "Pays de Galles", date_de_naissance: "1974-11-08"})
        db_emmy.tables["acteurs"].addData({id: 2, nom: "Bateman", prenom: "Jason", sexe: "M", pays: "États-Unis", date_de_naissance: "1969-01-14"})
        db_emmy.tables["acteurs"].addData({id: 3, nom: "Brown", prenom: "Sterling K.", sexe: "M", pays: "États-Unis", date_de_naissance: "1976-04-05"})
        db_emmy.tables["acteurs"].addData({id: 4, nom: "Harris", prenom: "Ed", sexe: "M", pays: "États-Unis", date_de_naissance: "1950-11-28"})
        db_emmy.tables["acteurs"].addData({id: 5, nom: "Ventimiglia", prenom: "Milo", sexe: "M", pays: "États-Unis", date_de_naissance: "1977-07-08"})
        db_emmy.tables["acteurs"].addData({id: 6, nom: "Wright", prenom: "Jeffrey", sexe: "M", pays: "États-Unis", date_de_naissance: "1965-12-07"})
        db_emmy.tables["acteurs"].addData({id: 7, nom: "Foy", prenom: "Claire", sexe: "F", pays: "Angleterre", date_de_naissance: "1984-04-16"})
        db_emmy.tables["acteurs"].addData({id: 8, nom: "Maslany", prenom: "Tatiana", sexe: "F", pays: "Canada", date_de_naissance: "1985-09-22"})
        db_emmy.tables["acteurs"].addData({id: 9, nom: "Moss", prenom: "Elisabeth", sexe: "F", pays: "États-Unis", date_de_naissance: "1982-07-24"})
        db_emmy.tables["acteurs"].addData({id: 10, nom: "Oh", prenom: "Sandra", sexe: "F", pays: "Canada", date_de_naissance: "1970-11-30"})
        db_emmy.tables["acteurs"].addData({id: 11, nom: "Russell", prenom: "Keri", sexe: "F", pays: "États-Unis", date_de_naissance: "1976-03-23"})
        db_emmy.tables["acteurs"].addData({id: 12, nom: "Wood", prenom: "Evan Rachel", sexe: "F", pays: "États-Unis", date_de_naissance: "1987-09-07"})
        db_emmy.tables["acteurs"].addData({id: 13, nom: "Dinklage", prenom: "Peter", sexe: "M", pays: "États-Unis", date_de_naissance: "1969-06-11"})
        db_emmy.tables["acteurs"].addData({id: 14, nom: "Coster-Waldau", prenom: "Nikolaj", sexe: "M", pays: "Danemark", date_de_naissance: "1970-07-27"})
        db_emmy.tables["acteurs"].addData({id: 15, nom: "Fiennes", prenom: "Joseph", sexe: "M", pays: "Angleterre", date_de_naissance: "1970-05-27"})
        db_emmy.tables["acteurs"].addData({id: 16, nom: "Harbour", prenom: "David", sexe: "M", pays: "États-Unis", date_de_naissance: "1975-04-10"})
        db_emmy.tables["acteurs"].addData({id: 17, nom: "Patinkin", prenom: "Mandy", sexe: "M", pays: "États-Unis", date_de_naissance: "1952-11-30"})
        db_emmy.tables["acteurs"].addData({id: 18, nom: "Smith", prenom: "Matthew", sexe: "M", pays: "Angleterre", date_de_naissance: "1982-10-28"})
        db_emmy.tables["acteurs"].addData({id: 19, nom: "Newton", prenom: "Thandie", sexe: "F", pays: "Angleterre", date_de_naissance: "1972-11-06"})
        db_emmy.tables["acteurs"].addData({id: 20, nom: "Bledel", prenom: "Alexis", sexe: "F", pays: "États-Unis", date_de_naissance: "1981-09-16"})
        db_emmy.tables["acteurs"].addData({id: 21, nom: "Brown", prenom: "Millie Bobby", sexe: "F", pays: "Espagne", date_de_naissance: "2004-02-19"})
        db_emmy.tables["acteurs"].addData({id: 22, nom: "Dowd", prenom: "Ann", sexe: "F", pays: "États-Unis", date_de_naissance: "1956-01-30"})
        db_emmy.tables["acteurs"].addData({id: 23, nom: "Heady", prenom: "Lena", sexe: "F", pays: "Royaume-Uni", date_de_naissance: "1973-10-03"})
        db_emmy.tables["acteurs"].addData({id: 24, nom: "Kirby", prenom: "Vanessa", sexe: "F", pays: "Angleterre", date_de_naissance: "1988-04-18"})
        db_emmy.tables["acteurs"].addData({id: 25, nom: "Strahovski", prenom: "Yvonne", sexe: "F", pays: "Australie", date_de_naissance: "1982-07-30"})

        db_emmy.addTable("tourne")
        db_emmy.tables["tourne"].addColumn("id_acteur", "SMALLINT")
        db_emmy.tables["tourne"].addColumn("id_serie", "SMALLINT")
        db_emmy.tables["tourne"].addColumn("role", "VARCHAR")
        db_emmy.tables["tourne"].addData({id_acteur: 1, id_serie: 2, role: "Philip Jennings"})
        db_emmy.tables["tourne"].addData({id_acteur: 2, id_serie: 8, role: 'Martin "Marty" Byrde'})
        db_emmy.tables["tourne"].addData({id_acteur: 3, id_serie: 6, role: "Randall Pearson"})
        db_emmy.tables["tourne"].addData({id_acteur: 4, id_serie: 7, role: "l'homme en noir"})
        db_emmy.tables["tourne"].addData({id_acteur: 5, id_serie: 6, role: "Jack Pearson"})
        db_emmy.tables["tourne"].addData({id_acteur: 6, id_serie: 7, role: "Bernard Lowe"})
        db_emmy.tables["tourne"].addData({id_acteur: 7, id_serie: 3, role: "Élisabeth II"})
        db_emmy.tables["tourne"].addData({id_acteur: 8, id_serie: 9, role: "Sarah Manning"})
        db_emmy.tables["tourne"].addData({id_acteur: 8, id_serie: 9, role: "Elizabeth « Beth » Childs"})
        db_emmy.tables["tourne"].addData({id_acteur: 8, id_serie: 9, role: "Cosima Niehaus"})
        db_emmy.tables["tourne"].addData({id_acteur: 8, id_serie: 9, role: "Alison Hendrix"})
        db_emmy.tables["tourne"].addData({id_acteur: 8, id_serie: 9, role: "Helena"})
        db_emmy.tables["tourne"].addData({id_acteur: 8, id_serie: 9, role: "Rachel Duncan"})
        db_emmy.tables["tourne"].addData({id_acteur: 8, id_serie: 9, role: "Katja Obinger"})
        db_emmy.tables["tourne"].addData({id_acteur: 8, id_serie: 9, role: "Danielle Fournier"})
        db_emmy.tables["tourne"].addData({id_acteur: 8, id_serie: 9, role: "Aryanna Giordano"})
        db_emmy.tables["tourne"].addData({id_acteur: 8, id_serie: 9, role: "Janika Zingler"})
        db_emmy.tables["tourne"].addData({id_acteur: 8, id_serie: 9, role: "Jennifer Fitzsimmons"})
        db_emmy.tables["tourne"].addData({id_acteur: 8, id_serie: 9, role: "Tony Sawicki"})
        db_emmy.tables["tourne"].addData({id_acteur: 8, id_serie: 9, role: "Krystal Goderitch"})
        db_emmy.tables["tourne"].addData({id_acteur: 8, id_serie: 9, role: "MK (Veera Suominen)"})
        db_emmy.tables["tourne"].addData({id_acteur: 8, id_serie: 9, role: "Niki"})
        db_emmy.tables["tourne"].addData({id_acteur: 8, id_serie: 9, role: "Miriam Johnson"})
        db_emmy.tables["tourne"].addData({id_acteur: 8, id_serie: 9, role: "Camilla Torres"})
        db_emmy.tables["tourne"].addData({id_acteur: 9, id_serie: 4, role: "June Osborne-Offred"})
        db_emmy.tables["tourne"].addData({id_acteur: 10, id_serie: 10, role: "Eve Polastri"})
        db_emmy.tables["tourne"].addData({id_acteur: 11, id_serie: 2, role: "Elizabeth Jennings"})
        db_emmy.tables["tourne"].addData({id_acteur: 12, id_serie: 7, role: "Dolores Abernathy"})
        db_emmy.tables["tourne"].addData({id_acteur: 13, id_serie: 1, role: "Tyrion Lannister"})
        db_emmy.tables["tourne"].addData({id_acteur: 14, id_serie: 1, role: "Jaime Lannister"})
        db_emmy.tables["tourne"].addData({id_acteur: 15, id_serie: 4, role: "Fred Waterford"})
        db_emmy.tables["tourne"].addData({id_acteur: 16, id_serie: 5, role: "Jim Hopper"})
        db_emmy.tables["tourne"].addData({id_acteur: 17, id_serie: 11, role: "Saul Berenson"})
        db_emmy.tables["tourne"].addData({id_acteur: 18, id_serie: 3, role: "Prince Philip"})
        db_emmy.tables["tourne"].addData({id_acteur: 19, id_serie: 7, role: "Maeve Millay"})
        db_emmy.tables["tourne"].addData({id_acteur: 20, id_serie: 4, role: "Emily"})
        db_emmy.tables["tourne"].addData({id_acteur: 21, id_serie: 5, role: "Jane Ives / Onze"})
        db_emmy.tables["tourne"].addData({id_acteur: 22, id_serie: 4, role: "Tante Lydia"})
        db_emmy.tables["tourne"].addData({id_acteur: 23, id_serie: 1, role: "Cersei Lannister"})
        db_emmy.tables["tourne"].addData({id_acteur: 24, id_serie: 3, role: "Princesse Margaret"})
        db_emmy.tables["tourne"].addData({id_acteur: 25, id_serie: 4, role: "Serena Joy Waterford"})
        databases.push(db_emmy)
    </script>
</body>
</html>
l
